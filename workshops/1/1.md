# Workshop 1

+ [problems_1.pdf](https://github.com/ChrisLinn/comp90054-cheat/blob/master/workshops/1/problems_1.pdf)
+ [solutions_1.pdf](https://github.com/ChrisLinn/comp90054-cheat/blob/master/workshops/1/solutions_1.pdf)

## 1. State Model
+ 8-Puzzle
    * State space `S`
        - a set of all unique-sequenced `array[0..8] of 0..8` indicating the digit on each position in the frame, with `0` representing the missing tile
    * Initial state `s_0 ∈ S`
    * Set of _goal_ states `S_G ⊆ S`
        - `S_G` = `{[1,2,3,4,5,6,7,8,0]}`
    * Applicable actions function `A(s)` for each state `s ∈ S`
        - 
            ```
            A(s) = { <s, s'> | s' = s.swap(s.indexof(0), s.indexof(0)-1) /\ s,s' ∈ S }
            ∪ { <s, s'> | s' = s.swap(s.indexof(0), s.indexof(0)+1) /\ s,s' ∈ S }
            ∪ { <s, s'> | s' = s.swap(s.indexof(0), s.indexof(0)-3) /\ s,s' ∈ S }
            ∪ { <s, s'> | s' = s.swap(s.indexof(0), s.indexof(0)+3) /\ s,s' ∈ S }
            ```
    * Transition function `f(s, a)` for `s ∈ S` and `a ∈ A(s)`
        - `f(s, <s, s'>) = s'`
    * Cost of each action `c(a, s)` for `s ∈ S` and `a ∈ A(s)`
        - `c(a, s) = 1` for `s ∈ S` and `a ∈ A(s)`
+ Travelling Salesman Problem
    * Consider a set of cities `V` to visit in any order, a starting city location `v_start` , and a set of edges `E` specifying if there’s an edge from two cities `<v, v'>`
        - State space `S`
            + `S = { <v_current, V_current> | v_current ∈ V, V_current ⊆ V }`
        - Initial state `s_0 ∈ S`
            + if needing to return to the first city
                * `s_0 = <v_start, V>`
                * or `s_0 = <v_start, {}>`
            + if not needing to return to the first city
                * `s_0 = <v_start, V - {v_start}>`
                * or `s_0 = <v_start, {v_start}>`
        - Set of _goal_ states `S_G ⊆ S`
            + `{ <v, {}> | v ∈ V }`
            + or `{ <v, V> | v ∈ V }`
        - Applicable actions function `A(s)` for each state `s ∈ S`
            + `A(s) = { <v, v'> | <v, v'> ∈ E }`
        - Transition function `f(s, a)` for `s ∈ S` and `a ∈ A(s)`
            + `f(<v_current, V_current>, <v_current, v'>) = <v', V_current - {v'}>`
            + or `f(<v_current, V_current>, <v_current, v'>) = <v', V_current ∪ {v'}>`
        - Cost of each action `c(a, s)` for `s ∈ S` and `a ∈ A(s)`

