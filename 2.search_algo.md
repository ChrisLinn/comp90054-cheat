# Search Algorithms

## Classical Planning
+ Basic State Model
    * directed graphs
+ search algo
    * Blind search vs. Heuristic (or informed) search
        - Blind search
            + DFS
            + BFS
            + Uniform cost (Dijkstra)
            + Iterative Deepening (ID)
        - Heuristic search
            + A*
            + IDA*
            + Hill Climbing
            + Best First
            + WA*
            + DFS B&B
            + LRTA*
    * Systematic search vs. Local search
        - Systematic search
            + consider a large number of search nodes simultaneously
        - Local search
            + work with one (or a few) candidate solutions (search nodes) at a time
        - can overlap
            + hill-climbing
    + when to use?
        * satisfying planning
            - Heuristic >> Blind
            - Systematic ~ Local
        * optimal planning
            - Heuristic > Blind
            - has to be Systematic

## Terminology
+ Search node
+ Path cost
+ Optimal cost
+ Node expansion
+ Search strategy
+ Open list (Frontier)
+ Closed list (explored set)
    * only used in graph search
        - not in tree search

## Progression vs. Regression
+ progression
    * forward
    * default in this course
    * search states = world states
+ regression
    * backward
    * search states = sub-goals we would need to achieve
        -  search states != world states

## Search States != Search Nodes
Search Nodes = Parent + Action + Cost + Search States

## Evaluation
* Guarantees
    - Completeness
        + can find a solution
    - Optimality
* Complexity
    - time
        + how many __generated__ states
    - space
        + how many states
    * factors
        - Branching factor
        - Goal depth

## Blind search
+ BFS
    * low time complexity.
        - Variant: Uniform cost search
    * Guarantees
        - complete
        - optimal for non-decreasing action cost
    * Complexity
        - space
        - time
            + O(b^d)
+ DFS
    * low space complexity
    * Guarantees
        - complete when no cycles
        - no
    * complexity
        - space
            + O(b*m)  (b*d?)
        - time
            + worst: O(b^m)
            + best: O(b*l)
+ Iterative deepening search (preferrd blind search method in large state spaces with unknown solution depth)
    * low complexity in both time and space
    * Uses depth-limited search as a sub-procedure
    * Guarantees
        - complete
        - optimal
    * Complexity
        - space
            + O(b*d)
        - time
            + O(b^d)
+ Bi-directional search
    * will not be examed

## Heuristic search
+ heuristic function (for the optimal path)
    * search gives preference
    * property
        - can be
            + safe
            + goal-aware
            + admissible
            + consistent
        - relationships between properties
+ remaining cost `h*`
+ performance depends crucially on "how well `h` reflects `h*`"
    * the imformedness of `h`
    * the computational overhead of computing `h`
    * extreme cases
        - `h = h*`
        - `h = 0`

### systematic heuristic search
+ Greedy Best-First Search
    * priority queue
        - min heap
    * complete
    * not optimal
        - even for perfect heuristic, (e.g., start --1000-->goal and start --0--> goal,) nothing prevents it from choosing the bad one
+ A*
    * with duplicate detecion and re-openning
    * terminology
        - f-value
        - generated nodes
        - expanded nodes
        - re-expanded nodes
    * proper
        - complete
            + yes for safe (even without duplication detection)
        - optimal
            + yes for admissible (even without duplication detection)
    * if `h = 0`
        - _A*_ becomes _uniform-cost_

### local heuristic search
+ hill-climbing
+ enforced hill-climbing

