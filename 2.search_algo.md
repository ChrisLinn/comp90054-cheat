# Search Algorithms

## State Model
+ state space
    * finite and discrete
+ a initial state
+ a __set__ of goal states
+ applicable actions for each state
+ deterministic transition function s' = f(a, s)
+ cost c(a, s)

## Classical Planning
+ Basic State Model
    * directed graphs
+ search algo
    * Blind search vs. Heuristic (or informed) search
        - Blind search
            + DFS
            + BFS
            + Uniform cost (Dijkstra)
            + Iterative Deepening (ID)
        - Heuristic search
            + A*
            + IDA*
            + Hill Climbing
            + Best First
            + WA*
            + DFS B&B
            + LRTA*
    * Systematic search vs. Local search
        - Systematic search
            + consider a large number of search nodes simultaneously
        - Local search
            + work with one (or a few) candidate solutions (search nodes) at a time
        - can overlap
            + hill-climbing
    + when to use?
        * satisfying planning
            - Heuristic >> Blind
            - Systematic ~ Local
        * optimal planning
            - Heuristic > Blind
            - has to be Systematic

## Terminology
+ Search node
+ Path cost
+ Optimal cost
+ Node expansion
+ Search strategy
+ Open list (Frontier)
+ Closed list (explored set)
    * only used in graph search
        - not in tree search

## Progression vs. Regression
+ progression
    * forward
    * default in this course
    * search states = world states
+ regression
    * backward
    * search states = sub-goals we would need to achieve
        -  search states != world states

## Search States != Search Nodes
Search Nodes = Parent + Action + Cost + Search States

## Evaluation
* Guarantees
    - Completeness
        + can find a solution
    - Optimality
* Complexity
    - time
    - space
    * factors
        - Branching factor
        - Goal depth

## Blind search
+ BFS
    * low time complexity.
        - Variant: Uniform cost search (Dijkstra)
    * Guarantees
        - complete
        - optimal for uniform action cost
            + 若所有边的长度相等，广度优先搜索算法是最佳解——亦即它找到的第一个解，距离根节点的边数目一定最少；但对一般的图来说，BFS并不一定回传最佳解。这是因为当图形为加权图（亦即各边长度不同）时，BFS仍然回传从根节点开始，经过边数目最少的解；而这个解距离根节点的距离不一定最短。这个问题可以使用考虑各边权值，BFS的改良算法成本一致搜寻法 (Uniform cost search, Dijkstra) 来解决。然而，若非加权图形，则所有边的长度相等，BFS就能找到最近的最佳解。
    * Complexity
        - space
            + O(b^d), O(|V| + |E|)
        - time
            + O(b^d), O(|V| + |E|)
+ DFS
    * low space complexity
    * Guarantees
        - complete when no cycles
            + if we record the visited nodes, can DFS be complete even if there is a cycle?
                * if there are infinite nodes, DFS might get unlucky and follow one route that can visit infinite nodes. However, BFS goes down by levels, which means it is able to find shortest path. That is why even recording visited nodes still cannot guarantee DFS be complete when there is infinite nodes.
        - not optimal
    * complexity, m is the max depth reached
        - space
            + O(b*m)
        - time
            + worst: O(b^m)
            + best: O(b*l)
+ Iterative deepening search (preferrd blind search method in large state spaces with unknown solution depth)
    * low complexity in both time and space
    * Uses depth-limited search as a sub-procedure
    * Guarantees
        - complete
        - optimal
            + better than DFS
    * Complexity
        - space
            + O(b*d)
            + better than BFS
        - time
            + O(b^d)
+ Bi-directional search
    * will not be examed

## Heuristic search
+ heuristic function (for the optimal path),  __estimate__ the distance (or __remaining cost__) to the goal
    * search gives preference
    * property
        - can be
            + safe
            + goal-aware
            + admissible
            + consistent
        - relationships between properties
+ remaining cost `h*`
+ performance depends crucially on "how well `h` reflects `h*`"
    * the imformedness of `h`
    * the computational overhead of computing `h`
    * extreme cases
        - `h = h*`
        - `h = 0`

### systematic heuristic search
+ Greedy Best-First Search
    * priority queue
        - min heap
    * complete
    * not optimal
        - even for perfect heuristic, (e.g., start --1000-->goal and start --0--> goal,) nothing prevents it from choosing the bad one
+ A*
    * with duplicate detecion and re-openning
    * terminology
        - f-value
        - generated nodes
        - expanded nodes
        - re-expanded nodes
    * proper
        - complete
            + yes for safe (even without duplication detection)
        - optimal
            + yes for admissible (even without duplication detection)
    * if `h = 0`
        - _A*_ becomes _uniform-cost_

### local heuristic search
+ hill-climbing
+ enforced hill-climbing

